<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fruiting Chamber Calculator | Heartwood Mushrooms</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --brown-dark: #3b281e;
            --brown-medium: #5a4235;
            --tan: #d9bf90;
            --cream: #e7ded1;
            --cream-light: #f5f1eb;
            --forest-green: #455a30;
            --forest-green-light: #5a7a3d;
            --blue-accent: #545da3;
            --white: #ffffff;
            --shadow: rgba(59, 40, 30, 0.1);
            --shadow-strong: rgba(59, 40, 30, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, var(--cream-light) 0%, var(--cream) 100%);
            min-height: 100vh;
            color: var(--brown-dark);
            line-height: 1.6;
        }

        .container { max-width: 900px; margin: 0 auto; padding: 2rem 1rem; }

        header { text-align: center; margin-bottom: 2rem; }
        h1 { font-size: 2rem; font-weight: 700; color: var(--brown-dark); margin-bottom: 0.5rem; }
        .subtitle { color: var(--brown-medium); font-size: 1.1rem; }

        .calculator-card {
            background: var(--white);
            border-radius: 16px;
            box-shadow: 0 4px 24px var(--shadow), 0 1px 4px var(--shadow);
            overflow: hidden;
        }

        .input-section { padding: 2rem; background: var(--white); }
        .input-group { margin-bottom: 1.5rem; }
        .input-group:last-child { margin-bottom: 0; }

        label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: var(--brown-dark); }
        .input-hint { font-size: 0.85rem; color: var(--brown-medium); margin-bottom: 0.5rem; }

        .slider-container { position: relative; padding: 0.5rem 0; }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--tan) 0%, var(--forest-green) 100%);
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px; height: 24px;
            border-radius: 50%;
            background: var(--brown-dark);
            cursor: pointer;
            border: 3px solid var(--white);
            box-shadow: 0 2px 8px var(--shadow-strong);
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); }

        input[type="range"]::-moz-range-thumb {
            width: 24px; height: 24px;
            border-radius: 50%;
            background: var(--brown-dark);
            cursor: pointer;
            border: 3px solid var(--white);
            box-shadow: 0 2px 8px var(--shadow-strong);
        }

        .slider-value { text-align: center; font-size: 2.5rem; font-weight: 700; color: var(--forest-green); margin: 0.5rem 0; }
        .slider-value span { font-size: 1rem; color: var(--brown-medium); font-weight: 400; }

        /* Unit toggle at top */
        .unit-toggle-container { display: flex; justify-content: flex-end; margin-bottom: 1rem; }
        .unit-toggle {
            display: flex; gap: 0; border: 2px solid var(--tan); border-radius: 8px; overflow: hidden;
        }
        .unit-btn {
            padding: 0.4rem 1rem; border: none; background: var(--white);
            font-size: 0.85rem; font-weight: 600; color: var(--brown-medium);
            cursor: pointer; transition: all 0.2s ease;
        }
        .unit-btn:hover { background: var(--cream-light); }
        .unit-btn.active { background: var(--forest-green); color: var(--white); }

        .size-toggle { display: flex; gap: 0.75rem; margin-top: 0.5rem; }

        .size-btn {
            flex: 1; padding: 0.6rem 0.75rem;
            border: 2px solid var(--tan);
            border-radius: 8px;
            background: var(--white);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .size-btn:hover { border-color: var(--forest-green); background: var(--cream-light); }
        .size-btn.active { border-color: var(--forest-green); background: linear-gradient(135deg, rgba(69, 90, 48, 0.08) 0%, rgba(69, 90, 48, 0.04) 100%); }
        .size-btn .size-title { font-weight: 700; font-size: 1rem; color: var(--brown-dark); }
        .size-btn .size-desc { font-size: 0.75rem; color: var(--brown-medium); margin-top: 0.15rem; }
        .size-btn.active .size-title { color: var(--forest-green); }

        /* Species tile selector */
        .species-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-top: 0.5rem; }
        .species-tile {
            position: relative;
            padding: 0.75rem;
            border: 2px solid var(--tan);
            border-radius: 10px;
            background: var(--white);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .species-tile:hover { border-color: var(--forest-green); background: var(--cream-light); }
        .species-tile.selected { border-color: var(--forest-green); background: linear-gradient(135deg, rgba(69, 90, 48, 0.08) 0%, rgba(69, 90, 48, 0.04) 100%); }
        .species-tile.disabled { opacity: 0.6; cursor: not-allowed; }
        .species-tile.disabled:hover { border-color: var(--tan); background: var(--white); }
        .species-checkbox {
            position: absolute; top: 0.5rem; right: 0.5rem;
            width: 18px; height: 18px; border: 2px solid var(--tan);
            border-radius: 4px; background: var(--white);
            display: flex; align-items: center; justify-content: center;
        }
        .species-tile.selected .species-checkbox { border-color: var(--forest-green); background: var(--forest-green); }
        .species-checkbox::after {
            content: ''; display: none; width: 5px; height: 9px;
            border: solid var(--white); border-width: 0 2px 2px 0; transform: rotate(45deg);
        }
        .species-tile.selected .species-checkbox::after { display: block; }
        .species-name { font-weight: 700; font-size: 0.95rem; color: var(--brown-dark); margin-bottom: 0.15rem; }
        .species-latin { font-size: 0.75rem; color: var(--brown-medium); font-style: italic; margin-bottom: 0.4rem; }
        .species-info { font-size: 0.7rem; color: var(--brown-medium); line-height: 1.4; }
        .species-info span { display: block; }
        .species-tile.disabled .species-name { color: var(--brown-medium); }
        .coming-soon-badge {
            font-size: 0.65rem; font-weight: 600; color: var(--blue-accent);
            background: rgba(84, 93, 163, 0.1); padding: 0.15rem 0.4rem;
            border-radius: 4px; display: inline-block; margin-top: 0.25rem;
        }

        /* 3D Visualization */
        .viz-section { padding: 1.5rem 2rem; background: var(--cream-light); border-top: 1px solid var(--cream); }
        .viz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .viz-header h3 { font-size: 1rem; font-weight: 600; color: var(--brown-dark); }
        .viz-stats { font-size: 0.85rem; color: var(--brown-medium); }
        .tent-dimensions {
            text-align: center; padding: 0.5rem; margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #2a3a1f 0%, #1a2612 100%);
            border-radius: 8px 8px 0 0; color: var(--white); font-weight: 600; font-size: 1.1rem;
        }
        .tent-dimensions span { color: var(--tan); }

        .viz-wrapper {
            position: relative;
            display: flex;
            background: linear-gradient(135deg, #2a3a1f 0%, #1a2612 100%);
            border-radius: 0 0 12px 12px;
            overflow: hidden;
        }

        .viz-legend {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        .viz-legend-item { display: flex; align-items: center; gap: 0.4rem; font-size: 0.7rem; color: rgba(255,255,255,0.8); }
        .viz-legend-color { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }

        #viz-container {
            flex: 1; height: 350px;
            overflow: hidden;
            cursor: grab;
        }
        #viz-container:active { cursor: grabbing; }

        .week-selector { display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: center; }
        .week-btn {
            padding: 0.5rem 1.25rem;
            border: 2px solid var(--tan);
            border-radius: 8px;
            background: var(--white);
            color: var(--brown-dark);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .week-btn:hover { border-color: var(--forest-green); background: var(--cream-light); }
        .week-btn.active {
            border-color: var(--forest-green);
            background: var(--forest-green);
            color: var(--white);
        }
        .week-description {
            text-align: center;
            font-size: 0.85rem;
            color: var(--brown-medium);
            margin-top: 0.5rem;
            font-style: italic;
        }


        .results-section {
            background: linear-gradient(135deg, var(--brown-dark) 0%, var(--brown-medium) 100%);
            padding: 2rem;
            color: var(--white);
        }

        .results-header { text-align: center; margin-bottom: 1.5rem; }
        .results-header h2 { font-size: 1.3rem; font-weight: 600; color: var(--tan); margin-bottom: 0.25rem; }
        .results-header .target { font-size: 1.8rem; font-weight: 700; }
        .results-header .cycle-info { font-size: 0.95rem; color: var(--tan); margin-top: 0.5rem; }

        .results-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem; }
        .result-card { background: rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 1rem; backdrop-filter: blur(10px); }
        .result-card .label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--tan); margin-bottom: 0.35rem; }
        .result-card .value { font-size: 1.3rem; font-weight: 700; }
        .result-card .detail { font-size: 0.75rem; color: rgba(255, 255, 255, 0.7); margin-top: 0.2rem; }

        .spec-sheet { margin-top: 1.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 12px; padding: 1.5rem; }
        .spec-sheet h3 { font-size: 1rem; color: var(--tan); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 0.05em; }

        .spec-list { font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; font-size: 0.9rem; line-height: 1.8; }
        .spec-list .spec-row { display: flex; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding: 0.5rem 0; }
        .spec-list .spec-row:last-child { border-bottom: none; }
        .spec-list .spec-label { color: rgba(255, 255, 255, 0.7); flex: 1; }
        .spec-list .spec-qty { font-weight: 600; width: 3rem; text-align: center; color: var(--tan); }
        .spec-list .spec-value { font-weight: 600; text-align: right; }

        .tip-box { margin-bottom: 1.25rem; background: rgba(69, 90, 48, 0.3); border-left: 4px solid var(--forest-green-light); border-radius: 0 8px 8px 0; padding: 0.85rem 1.25rem; }
        .tip-box .tip-title { font-weight: 600; color: var(--forest-green-light); margin-bottom: 0.25rem; font-size: 0.9rem; }
        .tip-box p { font-size: 0.9rem; color: rgba(255, 255, 255, 0.9); }

        .copy-btn {
            display: block; width: 100%; margin-top: 1.5rem; padding: 1rem;
            background: var(--tan); color: var(--brown-dark);
            border: none; border-radius: 8px;
            font-size: 1rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s ease;
        }
        .copy-btn:hover { background: var(--cream); transform: translateY(-1px); }
        .copy-btn:active { transform: translateY(0); }

        footer { text-align: center; padding: 2rem 1rem; color: var(--brown-medium); font-size: 0.9rem; }
        footer a { color: var(--forest-green); text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        @media (max-width: 768px) {
            .results-grid { grid-template-columns: repeat(2, 1fr); }
            .species-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 600px) {
            .container { padding: 1rem; }
            h1 { font-size: 1.5rem; }
            .input-section, .results-section { padding: 1.5rem; }
            .slider-value { font-size: 2rem; }
            .size-toggle { flex-direction: column; }
            .results-grid { grid-template-columns: 1fr 1fr; }
            .result-card .value { font-size: 1.1rem; }
            #viz-container { height: 280px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Fruiting Chamber Calculator</h1>
            <p class="subtitle">Size your batch setup from target yield</p>
        </header>

        <div class="calculator-card">
            <div class="input-section">
                <div class="unit-toggle-container">
                    <div class="unit-toggle">
                        <button class="unit-btn active" data-unit="metric">Metric</button>
                        <button class="unit-btn" data-unit="imperial">Imperial</button>
                    </div>
                </div>

                <div class="input-group">
                    <label>Block Size</label>
                    <p class="input-hint">Master's mix supplemented block weight</p>
                    <div class="size-toggle">
                        <button class="size-btn active" data-size="5">
                            <div class="size-title">2.3 kg</div>
                            <div class="size-desc">23×18×18 cm</div>
                        </button>
                        <button class="size-btn" data-size="10">
                            <div class="size-title">4.5 kg</div>
                            <div class="size-desc">28×23×23 cm</div>
                        </button>
                    </div>
                </div>

                <div class="input-group">
                    <label>Species Selection</label>
                    <p class="input-hint">Select species to grow (incompatible temps use separate chambers)</p>
                    <div class="species-grid">
                        <div class="species-tile selected" data-species="blue-oyster" data-fruit-temp="cold">
                            <div class="species-checkbox"></div>
                            <div class="species-name">Blue Oyster</div>
                            <div class="species-latin">Pleurotus ostreatus var. columbinus</div>
                            <div class="species-info">
                                <span>Incubation: 12-14 days @ 21-24°C (70-75°F)</span>
                                <span>Fruiting: 10-14°C (50-57°F)</span>
                                <span>Pinning: 3-5 days from cutting</span>
                                <span>Harvest: 5-7 days from pins</span>
                            </div>
                        </div>
                        <div class="species-tile" data-species="lions-mane" data-fruit-temp="warm">
                            <div class="species-checkbox"></div>
                            <div class="species-name">Lion's Mane</div>
                            <div class="species-latin">Hericium erinaceus</div>
                            <div class="species-info">
                                <span>Incubation: 14-21 days @ 21-24°C (70-75°F)</span>
                                <span>Fruiting: 15-18°C (59-65°F)</span>
                                <span>Pinning: 5-7 days from cutting</span>
                                <span>Harvest: 7-10 days from pins</span>
                            </div>
                        </div>
                        <div class="species-tile" data-species="chestnut" data-fruit-temp="warm">
                            <div class="species-checkbox"></div>
                            <div class="species-name">Chestnut</div>
                            <div class="species-latin">Pholiota adiposa</div>
                            <div class="species-info">
                                <span>Incubation: 14-21 days @ 21-24°C (70-75°F)</span>
                                <span>Fruiting: 15-18°C (59-65°F)</span>
                                <span>Pinning: 7-10 days from cutting</span>
                                <span>Harvest: 5-7 days from pins</span>
                            </div>
                        </div>
                        <div class="species-tile" data-species="pioppino" data-fruit-temp="warm">
                            <div class="species-checkbox"></div>
                            <div class="species-name">Pioppino</div>
                            <div class="species-latin">Cyclocybe aegerita</div>
                            <div class="species-info">
                                <span>Incubation: 21-28 days @ 21-24°C (70-75°F)</span>
                                <span>Fruiting: 15-18°C (59-65°F)</span>
                                <span>Pinning: 10-14 days from cutting</span>
                                <span>Harvest: 7-10 days from pins</span>
                            </div>
                        </div>
                        <div class="species-tile" data-species="shiitake" data-fruit-temp="cold">
                            <div class="species-checkbox"></div>
                            <div class="species-name">Shiitake</div>
                            <div class="species-latin">Lentinula edodes</div>
                            <div class="species-info">
                                <span>Incubation: 60-90 days @ 21-24°C (70-75°F)</span>
                                <span>Fruiting: 10-16°C (50-60°F)</span>
                                <span>Pinning: 7-14 days from cold shock</span>
                                <span>Harvest: 5-8 days from pins</span>
                            </div>
                        </div>
                        <div class="species-tile" data-species="king-oyster" data-fruit-temp="cold">
                            <div class="species-checkbox"></div>
                            <div class="species-name">King Oyster</div>
                            <div class="species-latin">Pleurotus eryngii</div>
                            <div class="species-info">
                                <span>Incubation: 14-21 days @ 21-24°C (70-75°F)</span>
                                <span>Fruiting: 12-16°C (54-60°F)</span>
                                <span>Pinning: 5-7 days from cutting</span>
                                <span>Harvest: 7-10 days from pins</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Average Weekly Harvest</label>
                    <p class="input-hint">Target fresh mushroom yield (averaged across 4-week cycle)</p>
                    <div class="slider-container">
                        <input type="range" id="yield-slider" min="1" max="150" step="1" value="10">
                        <div class="slider-value"><span id="yield-value">10</span> <span id="yield-unit">kg/week avg</span></div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Biological Efficiency</label>
                    <div class="slider-container">
                        <input type="range" id="be-slider" min="0" max="150" step="5" value="70">
                        <div class="slider-value"><span id="be-value">70</span><span>% BE</span></div>
                    </div>
                </div>
            </div>

            <!-- 3D Visualization Section -->
            <div class="viz-section">
                <div class="viz-header">
                    <h3>Chamber Layout</h3>
                    <span class="viz-stats" id="viz-stats">Drag to rotate</span>
                </div>
                <div class="tent-dimensions" id="tent-dimensions">
                    <span id="tent-dims-display">4' × 4' × 6.5'</span> <span id="tent-dims-metric">(1.2m × 1.2m × 2.0m)</span>
                </div>
                <div class="viz-wrapper">
                    <div class="viz-legend">
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: #d9bf90;"></div>
                            <span>Tent</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: #888;"></div>
                            <span>Shelving</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: #f5f5f5;"></div>
                            <span>Blocks</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: #8a9bab;"></div>
                            <span>Fruiting</span>
                        </div>
                    </div>
                    <div id="viz-container"></div>
                </div>
                <div class="week-selector">
                    <button class="week-btn active" data-week="1">Week 1</button>
                    <button class="week-btn" data-week="2">Week 2</button>
                    <button class="week-btn" data-week="3">Week 3</button>
                </div>
                <div class="week-description" id="week-description">
                    First batch enters fruiting chamber (no pins yet)
                </div>
            </div>

            <div class="results-section">
                <div class="results-header">
                    <h2>BATCH SETUP</h2>
                    <div class="target" id="target-display">3 kg/week avg</div>
                    <div class="cycle-info" id="cycle-info">~4 kg weeks 1-3, week 4 cleaning</div>
                </div>

                <div class="tip-box" id="tip-box">
                    <div class="tip-title">Batch Cycle</div>
                    <p id="tip-text">3 weeks production, 1 week cleaning/restart. Full clean between batches reduces contamination risk.</p>
                </div>

                <div class="results-grid">
                    <div class="result-card">
                        <div class="label">Blocks per Batch</div>
                        <div class="value" id="blocks-value">19</div>
                        <div class="detail" id="blocks-detail">all in, all out</div>
                    </div>
                    <div class="result-card">
                        <div class="label">Chamber Size</div>
                        <div class="value" id="chamber-value">16 ft³</div>
                        <div class="detail" id="chamber-detail">2' × 2' × 4' tent</div>
                    </div>
                    <div class="result-card">
                        <div class="label">FAE Required</div>
                        <div class="value" id="fae-value">1.3 CFM</div>
                        <div class="detail" id="fae-detail">80mm fan on low</div>
                    </div>
                    <div class="result-card">
                        <div class="label">Fogger Size</div>
                        <div class="value" id="fogger-value">1-disc</div>
                        <div class="detail" id="fogger-detail">~7% duty cycle</div>
                    </div>
                </div>

                <div class="spec-sheet">
                    <h3>Full Spec Sheet</h3>
                    <div class="spec-list">
                        <div class="spec-row">
                            <span class="spec-label">Target (avg)</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-target">10 kg/week</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Species</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-species">1</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Production weeks</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-prod-weeks">~13 kg/wk for 3 weeks</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Block size</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-block-size">5 lb (2.3 kg)</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Biological efficiency</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-be">70%</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Yield per block</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-yield-block">0.64 kg</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Blocks per batch</span>
                            <span class="spec-qty" id="spec-blocks-qty"></span>
                            <span class="spec-value" id="spec-blocks">62</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Chamber</span>
                            <span class="spec-qty" id="spec-chamber-qty"></span>
                            <span class="spec-value" id="spec-chamber">4' × 4' × 6.5'</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Capacity (per chamber)</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-capacity">72 blocks (86% used)</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Shelving (per chamber)</span>
                            <span class="spec-qty" id="spec-shelving-qty"></span>
                            <span class="spec-value" id="spec-shelving">1× rack, 4 levels</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">FAE target (per chamber)</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-fae">8 exch/hr → 17 CFM</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Fan (w/ ducting)</span>
                            <span class="spec-qty" id="spec-fan-qty"></span>
                            <span class="spec-value" id="spec-fan">4" inline (~108 CFM rated)</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Humidity controller</span>
                            <span class="spec-qty" id="spec-humidity-qty"></span>
                            <span class="spec-value">85% RH (Inkbird IHC-200)</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Fogger</span>
                            <span class="spec-qty" id="spec-fogger-qty"></span>
                            <span class="spec-value" id="spec-fogger">House of Hydro 1-disc</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Duty Cycle</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-duty">~7%</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Disc Life</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value" id="spec-life">4-6 years</span>
                        </div>
                        <div class="spec-row">
                            <span class="spec-label">Temperature</span>
                            <span class="spec-qty"></span>
                            <span class="spec-value">18-21°C</span>
                        </div>
                    </div>
                </div>

                <button class="copy-btn" onclick="copySpecs()">Copy Spec Sheet</button>
            </div>
        </div>

        <footer>
            Calculator by <a href="https://heartwoodmushrooms.ca" target="_blank">Heartwood Mushrooms</a>
        </footer>
    </div>

    <script>
        // ============================================================
        // PHYSICAL DIMENSIONS (all in inches for calculations)
        // ============================================================

        // Block dimensions (width × depth × height when standing)
        const BLOCK_DIMS = {
            5: { w: 9, d: 7, h: 7, weight_kg: 2.3, weight_lb: 5, label: '5 lb (2.3 kg)' },
            10: { w: 11, d: 9, h: 9, weight_kg: 4.5, weight_lb: 10, label: '10 lb (4.5 kg)' }
        };

        // Spacing between blocks for airflow (inches)
        const BLOCK_SPACING = 3;

        // Wire rack shelving specs (standard metro/chrome shelving)
        const SHELF_DEPTH = 18;      // inches (standard wire shelf depth)
        const SHELF_SPACING = 18;    // inches between levels (block height + mushroom growth room)
        const SHELF_BOTTOM = 6;      // inches off floor for first shelf

        // Walkway width for larger tents (inches)
        const WALKWAY_WIDTH = 30;

        // ============================================================
        // TENT CONFIGURATIONS
        // ============================================================

        // Tent sizes with dimensions in feet
        // Capacity will be calculated based on actual shelf/block fitting
        const TENT_SIZES = [
            { dims: "2' × 2' × 4'", w: 2, d: 2, h: 4 },
            { dims: "2' × 2' × 5'", w: 2, d: 2, h: 5 },
            { dims: "2' × 4' × 5'", w: 2, d: 4, h: 5 },
            { dims: "4' × 2' × 6'", w: 4, d: 2, h: 6 },
            { dims: "3' × 3' × 6'", w: 3, d: 3, h: 6 },
            { dims: "4' × 4' × 6.5'", w: 4, d: 4, h: 6.5 },
            { dims: "4' × 4' × 7'", w: 4, d: 4, h: 7 },
            { dims: "5' × 5' × 7'", w: 5, d: 5, h: 7 },
            { dims: "8' × 4' × 7'", w: 8, d: 4, h: 7 },
            { dims: "8' × 8' × 7'", w: 8, d: 8, h: 7 },
            { dims: "10' × 10' × 8'", w: 10, d: 10, h: 8 }
        ];

        // ============================================================
        // OTHER CONSTANTS
        // ============================================================

        const DRY_MASS_RATIO = 0.4;
        const PRODUCTION_WEEKS = 3;
        const CYCLE_WEEKS = 4;
        const MOISTURE_CONTENT_85RH = 14.5;  // g/m³ at 20°C, 85% RH
        const DISC_LIFE_HOURS_MIN = 2500;
        const DISC_LIFE_HOURS_MAX = 3500;

        // FAE increases with tent size (more blocks = more CO2, longer air paths)
        // Static pressure from ducting reduces effective CFM by 50-70%
        const DUCT_LOSS_FACTOR = 2.5;  // Fan needs 2.5× rated CFM to deliver target

        const FOGGERS = [
            { name: "1-disc", fullName: "House of Hydro 1-disc", output: 500 },
            { name: "3-disc", fullName: "House of Hydro 3-disc", output: 1500 },
            { name: "5-disc", fullName: "House of Hydro 5-disc", output: 1900 },
            { name: "12-disc", fullName: "House of Hydro 12-disc", output: 6000 }
        ];

        // ============================================================
        // STATE
        // ============================================================

        let currentYield = 10;  // Always stored in kg internally
        let currentBlockSize = 5;
        let currentBE = 70;
        let selectedSpecies = ['blue-oyster'];  // Array of selected species IDs
        let currentWeek = 1;
        let currentUnit = 'metric';  // 'metric' or 'imperial'
        let currentCalcData = null;

        // Unit conversion helpers
        const KG_TO_LB = 2.20462;
        const FT_TO_M = 0.3048;
        const IN_TO_CM = 2.54;

        // ============================================================
        // CAPACITY CALCULATION - The core logic
        // ============================================================

        function calculateTentCapacity(tent, blockSize) {
            const block = BLOCK_DIMS[blockSize];
            const tentW = tent.w * 12;  // Convert feet to inches
            const tentD = tent.d * 12;
            const tentH = tent.h * 12;

            // Block footprint with spacing
            const blockFootprintW = block.w + BLOCK_SPACING;
            const blockFootprintD = block.d + BLOCK_SPACING;

            // Number of shelf levels that fit
            const usableHeight = tentH - SHELF_BOTTOM;
            const numLevels = Math.floor(usableHeight / SHELF_SPACING);

            // Determine shelving layout based on tent size
            let shelvingConfig = [];
            const needsWalkway = tentW > 48 || tentD > 48;

            // facing: direction mushrooms point (towards walkway/harvester)
            // 0 = +Z (forward), PI/2 = -X (left), -PI/2 = +X (right), PI = -Z (back)
            if (tentW <= 36 && tentD <= 36) {
                // Small tent: single rack against back wall, mushrooms face door
                const rackW = tentW - 4;
                const rackD = Math.min(SHELF_DEPTH, tentD - 4);
                shelvingConfig.push({ w: rackW, d: rackD, x: 0, z: -(tentD/2) + rackD/2 + 2, facing: 0 });
            } else if (!needsWalkway) {
                // Medium tent: shelving on back wall, maybe sides
                const rackW = tentW - 4;
                const rackD = Math.min(SHELF_DEPTH, tentD - 4);
                shelvingConfig.push({ w: rackW, d: rackD, x: 0, z: -(tentD/2) + rackD/2 + 2, facing: 0 });

                // Add side shelves if tent is deep enough - face towards center
                if (tentD > 36) {
                    const sideRackD = tentD - SHELF_DEPTH - 8;
                    shelvingConfig.push({ w: SHELF_DEPTH, d: sideRackD, x: -(tentW/2) + SHELF_DEPTH/2 + 2, z: SHELF_DEPTH/2, facing: -Math.PI/2 });
                    shelvingConfig.push({ w: SHELF_DEPTH, d: sideRackD, x: (tentW/2) - SHELF_DEPTH/2 - 2, z: SHELF_DEPTH/2, facing: Math.PI/2 });
                }
            } else {
                // Large tent: perimeter shelving with walkway
                // Back wall rack - face towards walkway (+Z)
                const backRackW = tentW - 4;
                shelvingConfig.push({ w: backRackW, d: SHELF_DEPTH, x: 0, z: -(tentD/2) + SHELF_DEPTH/2 + 2, facing: 0 });

                // Side racks - face towards center walkway
                const sideRackD = tentD - SHELF_DEPTH - WALKWAY_WIDTH - 4;
                if (sideRackD > 12) {
                    shelvingConfig.push({ w: SHELF_DEPTH, d: sideRackD, x: -(tentW/2) + SHELF_DEPTH/2 + 2, z: -(WALKWAY_WIDTH/2), facing: -Math.PI/2 });
                    shelvingConfig.push({ w: SHELF_DEPTH, d: sideRackD, x: (tentW/2) - SHELF_DEPTH/2 - 2, z: -(WALKWAY_WIDTH/2), facing: Math.PI/2 });
                }
            }

            // Calculate blocks per shelf configuration
            let totalCapacity = 0;
            let shelvesWithCapacity = [];

            shelvingConfig.forEach(shelf => {
                // Blocks that fit on this shelf's footprint
                const blocksWide = Math.floor(shelf.w / blockFootprintW);
                const blocksDeep = Math.floor(shelf.d / blockFootprintD);
                const blocksPerLevel = blocksWide * blocksDeep;
                const shelfCapacity = blocksPerLevel * numLevels;
                totalCapacity += shelfCapacity;

                shelvesWithCapacity.push({
                    ...shelf,
                    blocksWide,
                    blocksDeep,
                    blocksPerLevel,
                    numLevels
                });
            });

            return {
                capacity: totalCapacity,
                shelves: shelvesWithCapacity,
                numLevels,
                needsWalkway,
                tentW,
                tentD,
                tentH
            };
        }

        function findBestTent(blocksNeeded, blockSize) {
            for (const tent of TENT_SIZES) {
                const config = calculateTentCapacity(tent, blockSize);
                if (config.capacity >= blocksNeeded) {
                    return { tent, config };
                }
            }
            // Return largest if nothing fits
            const lastTent = TENT_SIZES[TENT_SIZES.length - 1];
            return { tent: lastTent, config: calculateTentCapacity(lastTent, blockSize) };
        }

        // ============================================================
        // THREE.JS VISUALIZATION
        // ============================================================

        let scene, camera, renderer, tentGroup;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function initThreeJS() {
            const container = document.getElementById('viz-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(6, 5, 8);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Improved lighting for standard materials
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Add fill light from the front
            const fillLight = new THREE.DirectionalLight(0xfff5e6, 0.4);
            fillLight.position.set(-3, 5, 10);
            scene.add(fillLight);

            // Subtle rim light
            const rimLight = new THREE.DirectionalLight(0xe6f0ff, 0.3);
            rimLight.position.set(0, 3, -8);
            scene.add(rimLight);

            tentGroup = new THREE.Group();
            scene.add(tentGroup);

            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);
            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onMouseUp);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('viz-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function onMouseDown(e) { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; }
        function onMouseMove(e) {
            if (!isDragging) return;
            tentGroup.rotation.y += (e.clientX - previousMousePosition.x) * 0.01;
            tentGroup.rotation.x = Math.max(-0.5, Math.min(0.5, tentGroup.rotation.x + (e.clientY - previousMousePosition.y) * 0.005));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }
        function onMouseUp() { isDragging = false; }
        function onTouchStart(e) { if (e.touches.length === 1) { e.preventDefault(); isDragging = true; previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } }
        function onTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            e.preventDefault();
            tentGroup.rotation.y += (e.touches[0].clientX - previousMousePosition.x) * 0.01;
            tentGroup.rotation.x = Math.max(-0.5, Math.min(0.5, tentGroup.rotation.x + (e.touches[0].clientY - previousMousePosition.y) * 0.005));
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }

        function createTextSprite(text, position, size = 0.15) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            ctx.fillStyle = '#d9bf90';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(size * 4, size, 1);
            return sprite;
        }

        // Create a rounded, slightly bulging substrate block
        function createSubstrateBlock(blockW, blockH, blockD) {
            const segments = 8;
            const radius = Math.min(blockW, blockH, blockD) * 0.12; // Corner radius
            const bulge = 0.08; // How much sides bulge out

            // Create custom geometry with rounded edges and slight bulge
            const shape = new THREE.Shape();
            const hw = blockW / 2 - radius;
            const hh = blockH / 2 - radius;

            // Rounded rectangle shape
            shape.moveTo(-hw, -hh - radius);
            shape.lineTo(-hw, hh);
            shape.quadraticCurveTo(-hw, hh + radius, -hw + radius, hh + radius);
            shape.lineTo(hw, hh + radius);
            shape.quadraticCurveTo(hw + radius, hh + radius, hw + radius, hh);
            shape.lineTo(hw + radius, -hh);
            shape.quadraticCurveTo(hw + radius, -hh - radius, hw, -hh - radius);
            shape.lineTo(-hw + radius, -hh - radius);
            shape.quadraticCurveTo(-hw, -hh - radius, -hw, -hh);

            const extrudeSettings = {
                steps: 2,
                depth: blockD,
                bevelEnabled: true,
                bevelThickness: radius,
                bevelSize: radius,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();

            // Apply slight bulge to vertices
            const pos = geometry.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z = pos.getZ(i);

                // Bulge factor based on distance from center on each axis
                const xNorm = x / (blockW / 2);
                const yNorm = y / (blockH / 2);
                const zNorm = z / (blockD / 2);

                // Bulge outward more in the middle
                const xBulge = (1 - xNorm * xNorm) * bulge * blockW * Math.sign(x) * 0.5;
                const yBulge = (1 - yNorm * yNorm) * bulge * blockH * Math.sign(y) * 0.3;
                const zBulge = (1 - zNorm * zNorm) * bulge * blockD * Math.sign(z) * 0.5;

                pos.setX(i, x + (Math.abs(x) > blockW * 0.3 ? xBulge : 0));
                pos.setY(i, y + (Math.abs(y) > blockH * 0.3 ? yBulge : 0));
                pos.setZ(i, z + (Math.abs(z) > blockD * 0.3 ? zBulge : 0));
            }

            geometry.computeVertexNormals();
            return geometry;
        }

        // Create realistic oyster mushroom cluster
        // facingAngle: rotation in radians for which direction mushrooms face (0 = +Z, PI/2 = +X, etc)
        function createMushroomCluster(blockW, blockH, blockD, facingAngle = 0) {
            const cluster = new THREE.Group();

            // Materials - grey-blue oyster coloring
            const capTopMat = new THREE.MeshStandardMaterial({
                color: 0x8a9bab,  // Grey-blue cap
                roughness: 0.7,
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            const capBottomMat = new THREE.MeshStandardMaterial({
                color: 0xe8e6e2,  // Pale grey-white gills
                roughness: 0.5,
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            const stemMat = new THREE.MeshStandardMaterial({
                color: 0xf0eeea,  // Off-white stems
                roughness: 0.6,
                metalness: 0.0
            });

            // Scale mushrooms to be almost as large as the block
            const baseCapSize = Math.max(blockW, blockD) * 0.8;

            // Create 5-8 mushrooms in cluster
            const numMushrooms = 5 + Math.floor(Math.random() * 4);

            for (let i = 0; i < numMushrooms; i++) {
                const mushroom = new THREE.Group();

                // Vary cap size
                const capSize = baseCapSize * (0.5 + Math.random() * 0.6);
                const capWidth = capSize * (1.0 + Math.random() * 0.3);
                const capDepth = capSize * (0.7 + Math.random() * 0.3);
                const capThickness = capSize * 0.08;

                // Create fan/shell shaped cap using lathe geometry with custom profile
                const capPoints = [];
                const capSegments = 16;

                // Profile: flat with slight dome and curled edge
                for (let j = 0; j <= capSegments; j++) {
                    const t = j / capSegments;
                    const r = capWidth * t;
                    // Slight dome in middle, curl down at edges
                    let y;
                    if (t < 0.7) {
                        y = capThickness * (1 - t * 0.5) * Math.sin(t * Math.PI * 0.5);
                    } else {
                        y = capThickness * 0.3 * (1 - t) - capThickness * (t - 0.7) * 1.5;
                    }
                    capPoints.push(new THREE.Vector2(r, y));
                }

                // Lathe to create shell shape (partial rotation for fan effect)
                const capGeom = new THREE.LatheGeometry(capPoints, 20, 0, Math.PI * 1.15);

                // Add some waviness to the cap edge
                const capPos = capGeom.attributes.position;
                for (let j = 0; j < capPos.count; j++) {
                    const x = capPos.getX(j);
                    const y = capPos.getY(j);
                    const z = capPos.getZ(j);
                    const dist = Math.sqrt(x * x + z * z);

                    // Wavy edge
                    if (dist > capWidth * 0.6) {
                        const wave = Math.sin(Math.atan2(z, x) * 8) * capThickness * 0.3;
                        capPos.setY(j, y + wave * (dist / capWidth));
                    }
                }
                capGeom.computeVertexNormals();

                const capTop = new THREE.Mesh(capGeom, capTopMat);
                mushroom.add(capTop);

                // Gills on underside (simplified as radial lines texture via geometry)
                const gillGeom = new THREE.LatheGeometry(capPoints.map(p => new THREE.Vector2(p.x * 0.95, p.y - capThickness * 0.3)), 20, 0, Math.PI * 1.15);
                const gills = new THREE.Mesh(gillGeom, capBottomMat);
                mushroom.add(gills);

                // Eccentric stem (off-center, short, tapered)
                const stemHeight = capSize * 0.4;
                const stemRadius = capSize * 0.12;
                const stemGeom = new THREE.CylinderGeometry(stemRadius * 0.6, stemRadius, stemHeight, 8);

                // Bend the stem slightly
                const stemPos = stemGeom.attributes.position;
                for (let j = 0; j < stemPos.count; j++) {
                    const y = stemPos.getY(j);
                    const bendAmount = (y / stemHeight + 0.5) * stemRadius * 0.5;
                    stemPos.setZ(j, stemPos.getZ(j) + bendAmount);
                }
                stemGeom.computeVertexNormals();

                const stem = new THREE.Mesh(stemGeom, stemMat);
                stem.position.set(-capWidth * 0.15, -stemHeight * 0.4, capDepth * 0.1);
                stem.rotation.x = 0.2;
                mushroom.add(stem);

                // Position this mushroom in the cluster
                const clusterAngle = (i / numMushrooms) * Math.PI * 0.9 - Math.PI * 0.45;
                const clusterRadius = baseCapSize * 0.15 * (0.5 + Math.random());
                const verticalOffset = (i / numMushrooms - 0.5) * baseCapSize * 0.4;

                mushroom.position.set(
                    Math.sin(clusterAngle) * clusterRadius,
                    verticalOffset,
                    Math.cos(clusterAngle) * clusterRadius * 0.3 + baseCapSize * 0.3
                );

                // Rotate to fan outward
                mushroom.rotation.y = clusterAngle + Math.PI * 0.5;
                mushroom.rotation.x = -0.3 - Math.random() * 0.3;
                mushroom.rotation.z = (Math.random() - 0.5) * 0.2;

                cluster.add(mushroom);
            }

            // Rotate entire cluster to face the walking path
            cluster.rotation.y = facingAngle;

            return cluster;
        }

        function update3DViz(data) {
            if (!tentGroup) return;

            while (tentGroup.children.length > 0) {
                tentGroup.remove(tentGroup.children[0]);
            }

            const { tent, config, blocksNeeded, blocksPerTent, numTents } = data;
            const block = BLOCK_DIMS[currentBlockSize];

            // Scale: 1 unit = 1 foot for the visualization
            const w = tent.w;
            const d = tent.d;
            const h = tent.h;

            // Block dimensions in feet
            const blockW = block.w / 12;
            const blockD = block.d / 12;
            const blockH = block.h / 12;
            const spacing = BLOCK_SPACING / 12;
            const shelfSpacingFt = SHELF_SPACING / 12;
            const shelfBottomFt = SHELF_BOTTOM / 12;

            // Materials (shared across all tents)
            const shelfMat = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5 });
            const blockMat = new THREE.MeshStandardMaterial({ color: 0xf8f6f0, roughness: 0.9, metalness: 0.0 });
            const wallMat = new THREE.MeshBasicMaterial({ color: 0xd9bf90, transparent: true, opacity: 0.08, side: THREE.DoubleSide });
            const legMat = new THREE.MeshBasicMaterial({ color: 0x666666 });

            // Pre-create geometries (reuse for all blocks/tents)
            const blockGeometry = createSubstrateBlock(blockW, blockH, blockD);
            const tentGeom = new THREE.BoxGeometry(w, h, d);
            const tentEdges = new THREE.EdgesGeometry(tentGeom);
            const legGeom = new THREE.CylinderGeometry(0.02, 0.02, shelfBottomFt);

            // Calculate tent positions (side by side with gap)
            const tentGap = 1.5; // feet between tents
            const totalWidth = numTents > 1 ? (w * 2 + tentGap) : w;
            const tentOffsets = numTents > 1
                ? [-(w + tentGap) / 2, (w + tentGap) / 2]
                : [0];

            // Render each tent
            tentOffsets.forEach((xOffset, tentIndex) => {
                // Tent wireframe
                const tentLine = new THREE.LineSegments(tentEdges.clone(), new THREE.LineBasicMaterial({ color: 0xd9bf90, linewidth: 2 }));
                tentLine.position.set(xOffset, h / 2, 0);
                tentGroup.add(tentLine);

                // Semi-transparent walls
                const walls = new THREE.Mesh(tentGeom.clone(), wallMat);
                walls.position.set(xOffset, h / 2, 0);
                tentGroup.add(walls);

                // Dimension labels (only for first tent or single tent)
                if (tentIndex === 0 || numTents === 1) {
                    tentGroup.add(createTextSprite(`${tent.w}'`, new THREE.Vector3(xOffset, -0.3, d/2 + 0.3)));
                    tentGroup.add(createTextSprite(`${tent.d}'`, new THREE.Vector3(xOffset + w/2 + 0.3, -0.3, 0)));
                    tentGroup.add(createTextSprite(`${tent.h}'`, new THREE.Vector3(xOffset + w/2 + 0.3, h/2, -d/2 - 0.2)));
                }

                // Tent label for dual tents
                if (numTents > 1) {
                    tentGroup.add(createTextSprite(`Tent ${tentIndex + 1}`, new THREE.Vector3(xOffset, h + 0.3, 0), 0.2));
                }

                let blocksPlaced = 0;
                const blocksForThisTent = blocksPerTent;

                config.shelves.forEach(shelf => {
                    const shelfW = shelf.w / 12;
                    const shelfD = shelf.d / 12;
                    const shelfX = shelf.x / 12 + xOffset;
                    const shelfZ = shelf.z / 12;

                    for (let level = 0; level < config.numLevels; level++) {
                        const shelfY = shelfBottomFt + level * shelfSpacingFt;

                        // Draw shelf (thin box)
                        const shelfGeom = new THREE.BoxGeometry(shelfW, 0.02, shelfD);
                        const shelfMesh = new THREE.Mesh(shelfGeom, shelfMat);
                        shelfMesh.position.set(shelfX, shelfY, shelfZ);
                        tentGroup.add(shelfMesh);

                        // Draw shelf supports (4 legs)
                        if (level === 0) {
                            [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(([sx, sz]) => {
                                const leg = new THREE.Mesh(legGeom.clone(), legMat);
                                leg.position.set(shelfX + sx * (shelfW/2 - 0.05), shelfBottomFt/2, shelfZ + sz * (shelfD/2 - 0.05));
                                tentGroup.add(leg);
                            });
                        }

                        // Place blocks on this shelf
                        for (let row = 0; row < shelf.blocksDeep && blocksPlaced < blocksForThisTent; row++) {
                            for (let col = 0; col < shelf.blocksWide && blocksPlaced < blocksForThisTent; col++) {
                                // Determine if this block should be shown and if it should have mushrooms
                                // based on current week (staggered batch system)
                                const blockIndex = blocksPlaced;
                                const halfPoint = Math.ceil(blocksForThisTent / 2);
                                const isFirstHalf = blockIndex < halfPoint;

                                let showBlock = false;
                                let showMushrooms = false;

                                if (currentWeek === 1) {
                                    showBlock = isFirstHalf;
                                    showMushrooms = false;
                                } else if (currentWeek === 2) {
                                    showBlock = true;
                                    showMushrooms = isFirstHalf;
                                } else {
                                    showBlock = true;
                                    showMushrooms = !isFirstHalf;
                                }

                                if (showBlock) {
                                    const blockMesh = new THREE.Mesh(blockGeometry, blockMat);

                                    const bx = shelfX - shelfW/2 + (blockW + spacing)/2 + col * (blockW + spacing);
                                    const bz = shelfZ - shelfD/2 + (blockD + spacing)/2 + row * (blockD + spacing);
                                    const by = shelfY + blockH/2 + 0.02;

                                    blockMesh.position.set(bx, by, bz);
                                    tentGroup.add(blockMesh);

                                    if (showMushrooms) {
                                        const facing = shelf.facing || 0;
                                        const mushrooms = createMushroomCluster(blockW, blockH, blockD, facing);
                                        const mushroomOffset = blockD / 2 + 0.02;
                                        const mx = bx - Math.sin(facing) * mushroomOffset;
                                        const mz = bz + Math.cos(facing) * mushroomOffset;
                                        mushrooms.position.set(mx, by - blockH * 0.1, mz);
                                        tentGroup.add(mushrooms);
                                    }
                                }

                                blocksPlaced++;
                            }
                        }
                    }
                });
            });

            // Floor grid (spans all tents)
            const gridSize = Math.max(totalWidth, d) * 1.2;
            const gridHelper = new THREE.GridHelper(gridSize, Math.round(gridSize * 2), 0x444444, 0x333333);
            gridHelper.position.y = 0.001;
            tentGroup.add(gridHelper);

            // Adjust camera for dual tents
            const maxDim = Math.max(totalWidth, d, h);
            const cameraDistance = numTents > 1 ? maxDim * 1.1 : maxDim * 1.3;
            camera.position.set(cameraDistance, maxDim * 0.9, cameraDistance * 1.1);
            camera.lookAt(0, h * 0.35, 0);

            // Update stats based on week
            const halfPoint = Math.ceil(blocksPerTent / 2);
            let visibleBlocksPerTent, fruitingBlocksPerTent;
            if (currentWeek === 1) {
                visibleBlocksPerTent = halfPoint;
                fruitingBlocksPerTent = 0;
            } else if (currentWeek === 2) {
                visibleBlocksPerTent = blocksPerTent;
                fruitingBlocksPerTent = halfPoint;
            } else {
                visibleBlocksPerTent = blocksPerTent;
                fruitingBlocksPerTent = blocksPerTent - halfPoint;
            }

            if (numTents > 1) {
                document.getElementById('viz-stats').textContent =
                    `Week ${currentWeek}: ${visibleBlocksPerTent * numTents} blocks (${visibleBlocksPerTent}/tent), ${fruitingBlocksPerTent * numTents} fruiting`;
            } else {
                document.getElementById('viz-stats').textContent =
                    `Week ${currentWeek}: ${visibleBlocksPerTent} blocks, ${fruitingBlocksPerTent} fruiting`;
            }
        }

        // ============================================================
        // MAIN CALCULATION
        // ============================================================

        function calculate() {
            const block = BLOCK_DIMS[currentBlockSize];
            const beDecimal = currentBE / 100;

            const yieldPerBlock = block.weight_kg * DRY_MASS_RATIO * beDecimal;
            const totalCycleYield = currentYield * CYCLE_WEEKS;
            const blocksNeeded = yieldPerBlock > 0 ? Math.ceil(totalCycleYield / yieldPerBlock) : 0;
            const prodWeekYield = blocksNeeded > 0 ? (blocksNeeded * yieldPerBlock) / PRODUCTION_WEEKS : 0;

            // Determine if we need dual tents based on:
            // 1. 3+ species
            // 2. Incompatible fruiting temperatures (cold vs warm species mixed)
            const numSpecies = selectedSpecies.length;

            // Check temperature compatibility
            const speciesTiles = document.querySelectorAll('.species-tile.selected');
            let hasCold = false, hasWarm = false;
            speciesTiles.forEach(tile => {
                const temp = tile.dataset.fruitTemp;
                if (temp === 'cold') hasCold = true;
                if (temp === 'warm') hasWarm = true;
            });
            const incompatibleTemps = hasCold && hasWarm;

            // Need 2 tents if 3+ species OR incompatible temperatures
            const numTents = (numSpecies >= 3 || incompatibleTemps) ? 2 : 1;
            const blocksPerTent = Math.ceil(blocksNeeded / numTents);

            // Find best tent based on blocks per tent
            const { tent, config } = findBestTent(blocksPerTent, currentBlockSize);

            // FAE calculation - exchange rate scales with tent size
            // Small: 4-6/hr, Medium: 6-8/hr, Large: 8-12/hr
            const ft3 = tent.w * tent.d * tent.h;
            const m3 = ft3 * 0.0283168;

            // Scale air exchanges: more volume = higher rate needed for CO2 removal
            let exchangesPerHour;
            if (ft3 <= 40) exchangesPerHour = 5;
            else if (ft3 <= 120) exchangesPerHour = 6;
            else if (ft3 <= 200) exchangesPerHour = 8;
            else if (ft3 <= 400) exchangesPerHour = 10;
            else exchangesPerHour = 12;

            const targetCfm = (ft3 * exchangesPerHour) / 60;  // Actual airflow needed
            const fanRatedCfm = targetCfm * DUCT_LOSS_FACTOR;  // Fan rating to achieve target with ducting

            // Moisture/fogger (based on actual airflow, not fan rating)
            const exhaustM3PerHour = (targetCfm * 60) * 0.0283168;
            const moistureLossGPerHour = exhaustM3PerHour * MOISTURE_CONTENT_85RH;
            const fogger = FOGGERS.find(f => (moistureLossGPerHour / f.output) * 100 <= 50) || FOGGERS[FOGGERS.length - 1];
            const dutyCycle = Math.min(100, (moistureLossGPerHour / fogger.output) * 100);
            const runHoursPerDay = (dutyCycle / 100) * 24;

            const discLifeMonthsMin = Math.round((DISC_LIFE_HOURS_MIN / runHoursPerDay) / 30);
            const discLifeMonthsMax = Math.round((DISC_LIFE_HOURS_MAX / runHoursPerDay) / 30);

            // Fan recommendation based on rated CFM needed (accounting for duct losses)
            // 80mm PC: ~25 CFM rated, 120mm: ~50 CFM, 4" inline: ~200 CFM, 6" inline: ~400 CFM, 8" inline: ~700 CFM
            let fanRec, fanSize;
            if (fanRatedCfm <= 25) {
                fanRec = "80mm PC fan"; fanSize = "80mm";
            } else if (fanRatedCfm <= 50) {
                fanRec = "120mm PC fan"; fanSize = "120mm";
            } else if (fanRatedCfm <= 120) {
                fanRec = '4" inline fan'; fanSize = '4"';
            } else if (fanRatedCfm <= 250) {
                fanRec = '4" inline on high or 6" inline'; fanSize = '4-6"';
            } else if (fanRatedCfm <= 450) {
                fanRec = '6" inline fan'; fanSize = '6"';
            } else {
                fanRec = '8" inline fan'; fanSize = '8"';
            }

            const calcData = {
                block, yieldPerBlock, blocksNeeded, blocksPerTent, prodWeekYield,
                tent, config, ft3, m3, numTents, incompatibleTemps,
                exchangesPerHour, targetCfm, fanRatedCfm, fanRec, fanSize,
                fogger, dutyCycle, discLifeMonthsMin, discLifeMonthsMax,
                runHoursPerDay
            };

            currentCalcData = calcData;
            updateDisplay(calcData);
            update3DViz(calcData);
        }

        function updateDisplay(data) {
            const { block, yieldPerBlock, blocksNeeded, blocksPerTent, prodWeekYield, tent, config, ft3, m3, numTents, incompatibleTemps,
                    exchangesPerHour, targetCfm, fanRatedCfm, fanRec, fanSize,
                    fogger, dutyCycle, discLifeMonthsMin, discLifeMonthsMax, runHoursPerDay } = data;

            const isMetric = currentUnit === 'metric';
            const numSpecies = selectedSpecies.length;

            // Format weight based on unit
            const formatWeight = (kg) => isMetric ? `${kg.toFixed(1)} kg` : `${(kg * KG_TO_LB).toFixed(1)} lb`;
            const formatWeightShort = (kg) => isMetric ? `${kg.toFixed(2)} kg` : `${(kg * KG_TO_LB).toFixed(2)} lb`;

            // Format tent dimensions
            const formatTentDims = (t) => {
                if (isMetric) {
                    const wM = (t.w * FT_TO_M).toFixed(1);
                    const dM = (t.d * FT_TO_M).toFixed(1);
                    const hM = (t.h * FT_TO_M).toFixed(1);
                    return `${wM}m × ${dM}m × ${hM}m`;
                }
                return t.dims;
            };

            // Format volume
            const formatVolume = (ft3Val) => {
                if (isMetric) {
                    return `${(ft3Val * 0.0283168).toFixed(1)} m³`;
                }
                return `${Math.round(ft3Val)} ft³`;
            };

            // Format block dimensions
            const formatBlockDims = (b) => {
                if (isMetric) {
                    const wCm = Math.round(b.w * IN_TO_CM);
                    const dCm = Math.round(b.d * IN_TO_CM);
                    const hCm = Math.round(b.h * IN_TO_CM);
                    return `${wCm}×${dCm}×${hCm} cm`;
                }
                return `${b.w}"×${b.d}"×${b.h}"`;
            };

            // Update tent dimensions display
            const tentDimsDisplay = document.getElementById('tent-dims-display');
            const tentDimsMetric = document.getElementById('tent-dims-metric');
            if (numTents > 1) {
                tentDimsDisplay.textContent = `${numTents}× ${formatTentDims(tent)}`;
                tentDimsMetric.textContent = isMetric ? '' : `(${(tent.w * FT_TO_M).toFixed(1)}m × ${(tent.d * FT_TO_M).toFixed(1)}m × ${(tent.h * FT_TO_M).toFixed(1)}m each)`;
            } else {
                tentDimsDisplay.textContent = formatTentDims(tent);
                tentDimsMetric.textContent = isMetric ? '' : `(${(tent.w * FT_TO_M).toFixed(1)}m × ${(tent.d * FT_TO_M).toFixed(1)}m × ${(tent.h * FT_TO_M).toFixed(1)}m)`;
            }

            // Display yield in current unit
            const displayYield = isMetric ? currentYield : currentYield * KG_TO_LB;
            const yieldUnit = isMetric ? 'kg/week avg' : 'lb/week avg';
            document.getElementById('yield-unit').textContent = yieldUnit;

            document.getElementById('target-display').textContent = `${formatWeight(currentYield)}/week avg`;
            document.getElementById('cycle-info').textContent = `~${formatWeight(prodWeekYield)} weeks 1-3, week 4 cleaning`;

            document.getElementById('blocks-value').textContent = blocksNeeded;
            document.getElementById('blocks-detail').textContent = numTents > 1
                ? `${blocksPerTent}/tent × ${numTents} tents`
                : `capacity: ${config.capacity}`;

            const totalFt3 = ft3 * numTents;
            document.getElementById('chamber-value').textContent = formatVolume(numTents > 1 ? totalFt3 : ft3);
            document.getElementById('chamber-detail').textContent = numTents > 1
                ? `${numTents}× ${formatTentDims(tent)}`
                : formatTentDims(tent);

            document.getElementById('fae-value').textContent = fanSize;
            document.getElementById('fae-detail').textContent = numTents > 1
                ? `${numTents}× ${Math.round(fanRatedCfm)} CFM`
                : `${Math.round(fanRatedCfm)} CFM rated`;

            document.getElementById('fogger-value').textContent = fogger.name;
            document.getElementById('fogger-detail').textContent = numTents > 1
                ? `${numTents}× ~${Math.round(dutyCycle)}% duty`
                : `~${Math.round(dutyCycle)}% duty cycle`;

            // Spec sheet
            document.getElementById('spec-target').textContent = `${formatWeight(currentYield)}/week`;
            document.getElementById('spec-species').textContent = numSpecies;
            document.getElementById('spec-prod-weeks').textContent = `~${formatWeight(prodWeekYield)}/wk for 3 weeks`;

            // Block size display
            const blockLabel = isMetric ? `${block.weight_kg} kg` : `${block.weight_lb} lb`;
            document.getElementById('spec-block-size').textContent = `${blockLabel} (${formatBlockDims(block)})`;
            document.getElementById('spec-be').textContent = `${currentBE}%`;
            document.getElementById('spec-yield-block').textContent = formatWeightShort(yieldPerBlock);

            // Blocks with quantity
            document.getElementById('spec-blocks').textContent = numTents > 1 ? `${blocksPerTent} per tent` : blocksNeeded;
            document.getElementById('spec-blocks-qty').textContent = numTents > 1 ? `×${numTents}` : '';

            // Chamber with quantity
            document.getElementById('spec-chamber').textContent = `${formatTentDims(tent)} (${formatVolume(ft3)})`;
            document.getElementById('spec-chamber-qty').textContent = numTents > 1 ? `×${numTents}` : '';

            const utilizationPct = Math.round((blocksPerTent / config.capacity) * 100);
            document.getElementById('spec-capacity').textContent = `${config.capacity} blocks (${utilizationPct}% used)`;

            const numRacks = config.shelves.length;
            document.getElementById('spec-shelving').textContent = `${numRacks}× rack${numRacks > 1 ? 's' : ''}, ${config.numLevels} levels`;
            document.getElementById('spec-shelving-qty').textContent = numTents > 1 ? `×${numTents}` : '';

            document.getElementById('spec-fae').textContent = `${exchangesPerHour} exch/hr → ${Math.round(targetCfm)} CFM target`;
            document.getElementById('spec-fan').textContent = `${fanRec} (~${Math.round(fanRatedCfm)} CFM rated)`;
            document.getElementById('spec-fan-qty').textContent = numTents > 1 ? `×${numTents}` : '';

            document.getElementById('spec-humidity-qty').textContent = numTents > 1 ? `×${numTents}` : '';

            document.getElementById('spec-fogger').textContent = `${fogger.fullName}`;
            document.getElementById('spec-fogger-qty').textContent = numTents > 1 ? `×${numTents}` : '';

            document.getElementById('spec-duty').textContent = `~${Math.round(dutyCycle)}% (${runHoursPerDay.toFixed(1)} hrs/day)`;

            let discLifeText = discLifeMonthsMin >= 24
                ? `${Math.round(discLifeMonthsMin/12)}-${Math.round(discLifeMonthsMax/12)} years`
                : `${discLifeMonthsMin}-${discLifeMonthsMax} months`;
            document.getElementById('spec-life').textContent = discLifeText;

            // Tips
            const tipText = document.getElementById('tip-text');
            const tipTitle = document.querySelector('.tip-title');
            if (currentBE === 0) {
                tipTitle.textContent = "Note";
                tipText.textContent = "Set biological efficiency above 0% to calculate block requirements.";
            } else if (yieldPerBlock < 0.1) {
                tipTitle.textContent = "Note";
                tipText.textContent = "Very low BE results in minimal yield per block.";
            } else if (incompatibleTemps && numTents > 1) {
                tipTitle.textContent = "Dual Chambers Required";
                tipText.textContent = "Cold-fruiting species (10-16°C) and warm-fruiting species (15-18°C) need separate chambers. Harvest split equally between tents.";
            } else if (numTents > 1) {
                tipTitle.textContent = "Dual Chambers";
                tipText.textContent = `${numSpecies} species split across ${numTents} chambers for isolation. Each tent runs independently with half the harvest target.`;
            } else if (utilizationPct > 90) {
                tipTitle.textContent = "High Utilization";
                tipText.textContent = "Tent is nearly full. Good efficiency, but leave room for airflow between blocks.";
            } else if (utilizationPct < 50 && blocksNeeded > 10) {
                tipTitle.textContent = "Extra Capacity";
                tipText.textContent = "Tent has extra capacity. Consider a smaller tent or plan for growth.";
            } else if (config.needsWalkway) {
                tipTitle.textContent = "Layout";
                tipText.textContent = "Perimeter shelving layout with center walkway for access and harvesting.";
            } else {
                tipTitle.textContent = "Batch Cycle";
                tipText.textContent = "3 weeks production, 1 week cleaning/restart. Full clean between batches reduces contamination risk.";
            }
        }

        function copySpecs() {
            const specs = [];
            document.querySelectorAll('.spec-row').forEach(row => {
                const label = row.querySelector('.spec-label').textContent;
                const qty = row.querySelector('.spec-qty')?.textContent || '';
                const value = row.querySelector('.spec-value').textContent;
                if (qty) {
                    specs.push(`${label}: ${qty} ${value}`);
                } else {
                    specs.push(`${label}: ${value}`);
                }
            });

            const text = `FRUITING CHAMBER SPECS (BATCH MODE)\n${'='.repeat(40)}\n${specs.join('\n')}\n\nCalculated at growcalc.heartwoodmushrooms.ca`;

            navigator.clipboard.writeText(text).then(() => {
                const btn = document.querySelector('.copy-btn');
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy Spec Sheet', 2000);
            });
        }

        // ============================================================
        // INIT
        // ============================================================

        const yieldSlider = document.getElementById('yield-slider');
        const yieldValue = document.getElementById('yield-value');
        const beSlider = document.getElementById('be-slider');
        const beValue = document.getElementById('be-value');
        const sizeBtns = document.querySelectorAll('.size-btn');

        yieldSlider.addEventListener('input', (e) => {
            currentYield = parseFloat(e.target.value);
            yieldValue.textContent = currentYield;
            calculate();
        });

        beSlider.addEventListener('input', (e) => {
            currentBE = parseInt(e.target.value);
            beValue.textContent = currentBE;
            calculate();
        });

        sizeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                sizeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentBlockSize = parseInt(btn.dataset.size);
                calculate();
            });
        });

        // Unit toggle buttons
        const unitBtns = document.querySelectorAll('.unit-btn');
        unitBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                unitBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentUnit = btn.dataset.unit;
                updateBlockSizeDisplay();
                if (currentCalcData) {
                    updateDisplay(currentCalcData);
                }
            });
        });

        // Update block size button display based on current unit
        function updateBlockSizeDisplay() {
            const isMetric = currentUnit === 'metric';
            sizeBtns.forEach(btn => {
                const size = parseInt(btn.dataset.size);
                const block = BLOCK_DIMS[size];
                const title = btn.querySelector('.size-title');
                const desc = btn.querySelector('.size-desc');
                if (isMetric) {
                    title.textContent = `${block.weight_kg} kg`;
                    const wCm = Math.round(block.w * IN_TO_CM);
                    const dCm = Math.round(block.d * IN_TO_CM);
                    const hCm = Math.round(block.h * IN_TO_CM);
                    desc.textContent = `${wCm}×${dCm}×${hCm} cm`;
                } else {
                    title.textContent = `${block.weight_lb} lb`;
                    desc.textContent = `${block.w}"×${block.d}"×${block.h}"`;
                }
            });
        }

        // Species tile selection (multi-select checkboxes)
        const speciesTilesAll = document.querySelectorAll('.species-tile');
        speciesTilesAll.forEach(tile => {
            tile.addEventListener('click', () => {
                const speciesId = tile.dataset.species;

                if (tile.classList.contains('selected')) {
                    // Don't allow deselecting if it's the only one selected
                    if (selectedSpecies.length > 1) {
                        tile.classList.remove('selected');
                        selectedSpecies = selectedSpecies.filter(s => s !== speciesId);
                    }
                } else {
                    tile.classList.add('selected');
                    selectedSpecies.push(speciesId);
                }
                calculate();
            });
        });

        // Week selector buttons
        const weekBtns = document.querySelectorAll('.week-btn');
        const weekDescriptions = {
            1: 'First batch enters fruiting chamber (no pins yet)',
            2: 'First batch fruiting, second batch enters',
            3: 'First batch harvested, second batch fruiting'
        };

        weekBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                weekBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentWeek = parseInt(btn.dataset.week);
                document.getElementById('week-description').textContent = weekDescriptions[currentWeek];
                if (currentCalcData) {
                    update3DViz(currentCalcData);
                }
            });
        });

        initThreeJS();
        updateBlockSizeDisplay();
        calculate();
    </script>
</body>
</html>
